import React, { useState, useEffect } from 'react';
import PrimaryNavigation from '../../components/ui/PrimaryNavigation';
import FilterToolbar from '../../components/ui/FilterToolbar';
import VulnerabilityCard from './components/VulnerabilityCard';
import ScanSummaryCharts from './components/ScanSummaryCharts';
import FileTreeViewer from './components/FileTreeViewer';
import AIExplanationModal from './components/AIExplanationModal';
import BulkActionsBar from './components/BulkActionsBar';
import Button from '../../components/ui/Button';
import { Checkbox } from '../../components/ui/Checkbox';
import Icon from '../../components/AppIcon';

const VulnerabilityDashboard = () => {
  const [vulnerabilities, setVulnerabilities] = useState([]);
  const [filteredVulnerabilities, setFilteredVulnerabilities] = useState([]);
  const [selectedVulnerability, setSelectedVulnerability] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [selectedIds, setSelectedIds] = useState(new Set());
  const [showFileTree, setShowFileTree] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [activeFilters, setActiveFilters] = useState({});

  const mockVulnerabilities = [
    {
      id: "vuln-001",
      ruleName: "SQL Injection in User Authentication",
      severity: "High",
      owaspCategory: "A03:2021 - Injection",
      filePath: "src/auth/login.js",
      lineNumber: 45,
      description: "The application constructs SQL queries using string concatenation with user-supplied input without proper sanitization or parameterization. This allows attackers to inject malicious SQL code that can bypass authentication, extract sensitive data, or modify database contents.",
      codeSnippet: `const query = "SELECT * FROM users WHERE username = '" + username + "' AND password = '" + password + "'";
db.execute(query);`,
      suggestedFix: "Use parameterized queries or prepared statements to prevent SQL injection. Replace string concatenation with parameter binding to ensure user input is treated as data, not executable code.",
      isReviewed: false,
      aiExplanation: "This vulnerability occurs because the application directly concatenates user input into SQL queries without validation or escaping. An attacker could input malicious SQL code like ' OR '1'='1 to bypass authentication or extract database contents. The vulnerability exists at the database query construction level where untrusted input is treated as part of the SQL command structure.",
      correctedCode: `const query = "SELECT * FROM users WHERE username = ? AND password = ?";
db.execute(query, [username, hashedPassword]);`,
      implementationSteps: [
        "Replace all string concatenation in SQL queries with parameterized queries using prepared statements",
        "Implement input validation to reject suspicious patterns before query execution",
        "Use an ORM (Object-Relational Mapping) library that handles parameterization automatically",
        "Hash passwords using bcrypt or similar before comparison in the database",
        "Add logging and monitoring to detect SQL injection attempts"
      ],
      resources: [
        { title: "OWASP SQL Injection Prevention Cheat Sheet", url: "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html" },
        { title: "Parameterized Queries Best Practices", url: "https://example.com/parameterized-queries" }
      ]
    },
    {
      id: "vuln-002",
      ruleName: "Cross-Site Scripting (XSS) in Comment Section",
      severity: "High",
      owaspCategory: "A03:2021 - Injection",
      filePath: "src/components/CommentDisplay.jsx",
      lineNumber: 78,
      description: "User-generated content is rendered directly into the DOM without sanitization or encoding. This allows attackers to inject malicious JavaScript that executes in other users' browsers, potentially stealing session tokens, credentials, or performing actions on behalf of victims.",
      codeSnippet: `<div dangerouslySetInnerHTML={{ __html: userComment }} />`,
      suggestedFix: "Sanitize all user-generated content before rendering. Use a library like DOMPurify to remove malicious scripts, or use React's default text rendering which automatically escapes HTML entities.",
      isReviewed: false,
      aiExplanation: "The dangerouslySetInnerHTML prop in React bypasses React's built-in XSS protection by rendering raw HTML. If userComment contains <script> tags or event handlers like onclick, they will execute in the victim's browser. This is a stored XSS vulnerability because the malicious content is saved in the database and affects all users who view it.",
      correctedCode: `import DOMPurify from 'dompurify';

const sanitizedComment = DOMPurify.sanitize(userComment);
<div dangerouslySetInnerHTML={{ __html: sanitizedComment }} />

// Or better, use React's default rendering:
<div>{userComment}</div>`,
      implementationSteps: [
        "Install and configure DOMPurify library for HTML sanitization",
        "Replace all dangerouslySetInnerHTML usage with sanitized content",
        "Implement Content Security Policy (CSP) headers to prevent inline script execution",
        "Use React\'s default text rendering for simple text content",
        "Add input validation to reject suspicious HTML patterns at submission time"
      ],
      resources: [
        { title: "OWASP XSS Prevention Cheat Sheet", url: "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html" },
        { title: "DOMPurify Documentation", url: "https://github.com/cure53/DOMPurify" }
      ]
    },
    {
      id: "vuln-003",
      ruleName: "Hardcoded API Credentials",
      severity: "High",
      owaspCategory: "A07:2021 - Identification and Authentication Failures",
      filePath: "src/config/api.js",
      lineNumber: 12,
      description: "Sensitive API credentials are hardcoded directly in the source code. This exposes authentication secrets to anyone with access to the codebase, version control history, or compiled application files. Attackers can extract these credentials to gain unauthorized access to backend services.",
      codeSnippet: `const API_KEY = "sk_live_51HqJ8KLmN9pQrS0T1U2V3W4X5Y6Z7";
const API_SECRET = "whsec_a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6";`,
      suggestedFix: "Move all sensitive credentials to environment variables. Use a .env file for local development and secure secret management services for production. Never commit credentials to version control.",
      isReviewed: true,
      aiExplanation: "Hardcoded credentials in source code create multiple security risks: they're visible in version control history even after removal, can be extracted from compiled code, and are accessible to all developers with repository access. This violates the principle of least privilege and makes credential rotation extremely difficult.",
      correctedCode: `// .env file (never commit this)
API_KEY=sk_live_51HqJ8KLmN9pQrS0T1U2V3W4X5Y6Z7
API_SECRET=whsec_a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6

// api.js
const API_KEY = process.env.API_KEY;
const API_SECRET = process.env.API_SECRET;

if (!API_KEY || !API_SECRET) {
  throw new Error('Missing required API credentials');
}`,
      implementationSteps: [
        "Create a .env file and add it to .gitignore immediately","Move all hardcoded credentials to environment variables","Use dotenv package to load environment variables in development","Configure production environment to inject secrets securely (AWS Secrets Manager, Azure Key Vault, etc.)","Rotate all exposed credentials immediately","Scan git history and remove any committed credentials using tools like git-filter-repo"
      ],
      resources: [
        { title: "OWASP Secrets Management Cheat Sheet", url: "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html" },
        { title: "Environment Variables Best Practices", url: "https://example.com/env-vars" }
      ]
    },
    {
      id: "vuln-004",ruleName: "Insecure Direct Object Reference (IDOR)",severity: "Medium",owaspCategory: "A01:2021 - Broken Access Control",filePath: "src/api/userProfile.js",lineNumber: 34,description: "The application uses user-supplied input to directly access database objects without proper authorization checks. Attackers can manipulate object identifiers to access or modify resources belonging to other users.",
      codeSnippet: `app.get('/api/profile/:userId', (req, res) => {
  const userId = req.params.userId;
  const profile = db.getProfile(userId);
  res.json(profile);
});`,
      suggestedFix: "Implement proper authorization checks to verify that the authenticated user has permission to access the requested resource. Compare the requested userId with the authenticated user's session.",isReviewed: false,aiExplanation: "This endpoint allows any authenticated user to view any other user's profile by simply changing the userId parameter in the URL. There's no verification that the requesting user has permission to access the specified profile. This is a classic IDOR vulnerability where object references are exposed without access control.",
      correctedCode: `app.get('/api/profile/:userId', authenticateUser, (req, res) => {
  const requestedUserId = req.params.userId;
  const authenticatedUserId = req.user.id;
  
  // Check if user is accessing their own profile or has admin privileges
  if (requestedUserId !== authenticatedUserId && !req.user.isAdmin) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  const profile = db.getProfile(requestedUserId);
  res.json(profile);
});`,
      implementationSteps: [
        "Add authentication middleware to verify user identity",
        "Implement authorization checks before accessing resources",
        "Use indirect object references (mapping tables) instead of direct database IDs",
        "Log all access attempts for security monitoring",
        "Implement role-based access control (RBAC) for different permission levels"
      ],
      resources: [
        { title: "OWASP IDOR Prevention", url: "https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html" },
        { title: "Access Control Best Practices", url: "https://example.com/access-control" }
      ]
    },
    {
      id: "vuln-005",
      ruleName: "Missing Rate Limiting on Login Endpoint",
      severity: "Medium",
      owaspCategory: "A07:2021 - Identification and Authentication Failures",
      filePath: "src/api/auth.js",
      lineNumber: 56,
      description: "The login endpoint lacks rate limiting controls, allowing unlimited authentication attempts. This enables brute force attacks where attackers can systematically try thousands of password combinations to gain unauthorized access.",
      codeSnippet: `app.post('/api/login', async (req, res) => {
  const { username, password } = req.body;
  const user = await authenticateUser(username, password);
  if (user) {
    res.json({ token: generateToken(user) });
  } else {
    res.status(401).json({ error: 'Invalid credentials' });
  }
});`,
      suggestedFix: "Implement rate limiting to restrict the number of login attempts per IP address or username. Use exponential backoff for repeated failures and consider implementing CAPTCHA after multiple failed attempts.",
      isReviewed: false,
      aiExplanation: "Without rate limiting, attackers can make unlimited login attempts, making brute force and credential stuffing attacks feasible. Even with strong password policies, automated tools can try thousands of combinations per second. Rate limiting significantly increases the time and resources required for successful attacks.",
      correctedCode: `const rateLimit = require('express-rate-limit');

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts per window
  message: 'Too many login attempts, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
});

app.post('/api/login', loginLimiter, async (req, res) => {
  const { username, password } = req.body;
  const user = await authenticateUser(username, password);
  if (user) {
    res.json({ token: generateToken(user) });
  } else {
    res.status(401).json({ error: 'Invalid credentials' });
  }
});`,
      implementationSteps: [
        "Install and configure express-rate-limit or similar middleware",
        "Set appropriate rate limits based on your application's needs (e.g., 5 attempts per 15 minutes)","Implement account lockout after excessive failed attempts","Add CAPTCHA verification after 3 failed attempts","Log all failed login attempts for security monitoring","Consider implementing progressive delays between failed attempts"
      ],
      resources: [
        { title: "OWASP Authentication Cheat Sheet", url: "https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html" },
        { title: "Rate Limiting Best Practices", url: "https://example.com/rate-limiting" }
      ]
    },
    {
      id: "vuln-006",ruleName: "Weak Cryptographic Algorithm (MD5)",severity: "Medium",owaspCategory: "A02:2021 - Cryptographic Failures",filePath: "src/utils/encryption.js",lineNumber: 23,description: "The application uses MD5 for password hashing, which is cryptographically broken and vulnerable to collision attacks. MD5 hashes can be reversed using rainbow tables or brute force attacks in reasonable time.",
      codeSnippet: `const crypto = require('crypto');

function hashPassword(password) {
  return crypto.createHash('md5').update(password).digest('hex');
}`,
      suggestedFix: "Replace MD5 with modern password hashing algorithms like bcrypt, scrypt, or Argon2. These algorithms are specifically designed for password storage and include built-in salting and computational cost factors.",isReviewed: false,aiExplanation: "MD5 is a fast hashing algorithm designed for data integrity, not password security. Its speed makes it vulnerable to brute force attacks, and precomputed rainbow tables exist for common passwords. Modern password hashing algorithms like bcrypt are intentionally slow and include automatic salting to prevent these attacks.",
      correctedCode: `const bcrypt = require('bcrypt');

async function hashPassword(password) {
  const saltRounds = 12;
  return await bcrypt.hash(password, saltRounds);
}

async function verifyPassword(password, hash) {
  return await bcrypt.compare(password, hash);
}`,
      implementationSteps: [
        "Install bcrypt package (npm install bcrypt)","Replace all MD5 hashing with bcrypt.hash()","Update password verification to use bcrypt.compare()","Force password reset for all existing users to migrate to new hashing","Set appropriate cost factor (12 is recommended for 2024)","Document the migration process and timeline"
      ],
      resources: [
        { title: "OWASP Password Storage Cheat Sheet", url: "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html" },
        { title: "Bcrypt Documentation", url: "https://github.com/kelektiv/node.bcrypt.js" }
      ]
    },
    {
      id: "vuln-007",ruleName: "Insufficient Input Validation on File Upload",severity: "Low",owaspCategory: "A03:2021 - Injection",filePath: "src/api/upload.js",lineNumber: 67,description: "The file upload endpoint only validates file extensions client-side, allowing attackers to upload malicious files by manipulating the extension. This could lead to remote code execution if uploaded files are executed by the server.",
      codeSnippet: `app.post('/api/upload', upload.single('file'), (req, res) => {
  const file = req.file;
  res.json({ message: 'File uploaded successfully', filename: file.filename });
});`,
      suggestedFix: "Implement server-side validation of file types using magic numbers (file signatures) rather than extensions. Restrict file types to only those necessary for the application. Store uploaded files outside the web root and serve them through a separate handler.",isReviewed: false,aiExplanation: "Client-side validation can be easily bypassed by modifying the request. Relying solely on file extensions is insufficient because attackers can rename malicious files (e.g., shell.php.jpg). Proper validation should check the actual file content using magic numbers and MIME types.",
      correctedCode: `const fileType = require('file-type');
const path = require('path');

app.post('/api/upload', upload.single('file'), async (req, res) => {
  const file = req.file;
  
  // Validate file type using magic numbers
  const type = await fileType.fromFile(file.path);
  const allowedTypes = ['image/jpeg', 'image/png', 'application/pdf'];
  
  if (!type || !allowedTypes.includes(type.mime)) {
    fs.unlinkSync(file.path); // Delete invalid file
    return res.status(400).json({ error: 'Invalid file type' });
  }
  
  // Validate file size
  if (file.size > 5 * 1024 * 1024) { // 5MB limit
    fs.unlinkSync(file.path);
    return res.status(400).json({ error: 'File too large' });
  }
  
  res.json({ message: 'File uploaded successfully', filename: file.filename });
});`,
      implementationSteps: [
        "Install file-type package for magic number validation",
        "Define whitelist of allowed MIME types",
        "Implement server-side file type validation",
        "Add file size limits to prevent DoS attacks",
        "Store uploaded files outside the web root directory",
        "Generate random filenames to prevent path traversal",
        "Scan uploaded files with antivirus software if possible"
      ],
      resources: [
        { title: "OWASP File Upload Cheat Sheet", url: "https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html" },
        { title: "File Type Validation", url: "https://example.com/file-validation" }
      ]
    },
    {
      id: "vuln-008",
      ruleName: "Missing HTTPS Enforcement",
      severity: "Low",
      owaspCategory: "A02:2021 - Cryptographic Failures",
      filePath: "src/server.js",
      lineNumber: 15,
      description: "The application accepts HTTP connections without redirecting to HTTPS. This allows sensitive data like passwords and session tokens to be transmitted in plaintext, making them vulnerable to man-in-the-middle attacks.",
      codeSnippet: `const express = require('express');
const app = express();

app.listen(3000, () => {
  console.log('Server running on port 3000');
});`,
      suggestedFix: "Enforce HTTPS for all connections by redirecting HTTP requests to HTTPS. Implement HTTP Strict Transport Security (HSTS) headers to prevent protocol downgrade attacks.",
      isReviewed: true,
      aiExplanation: "Without HTTPS enforcement, attackers on the same network can intercept and read all traffic between the client and server. This includes passwords, session tokens, and personal data. HTTPS encryption prevents this by encrypting all data in transit.",
      correctedCode: `const express = require('express');
const https = require('https');
const fs = require('fs');
const app = express();

// Redirect HTTP to HTTPS
app.use((req, res, next) => {
  if (req.secure) {
    next();
  } else {
    res.redirect('https://' + req.headers.host + req.url);
  }
});

// Add HSTS header
app.use((req, res, next) => {
  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
  next();
});

const options = {
  key: fs.readFileSync('path/to/private-key.pem'),
  cert: fs.readFileSync('path/to/certificate.pem')
};

https.createServer(options, app).listen(443);`,
      implementationSteps: [
        "Obtain SSL/TLS certificate from a trusted Certificate Authority (Let's Encrypt is free)",
        "Configure server to listen on port 443 for HTTPS",
        "Implement HTTP to HTTPS redirect middleware",
        "Add HSTS header with appropriate max-age",
        "Update all internal links to use HTTPS",
        "Test certificate installation and renewal process",
        "Consider submitting domain to HSTS preload list"
      ],
      resources: [
        { title: "OWASP Transport Layer Protection Cheat Sheet", url: "https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html" },
        { title: "Let's Encrypt Documentation", url: "https://letsencrypt.org/docs/" }
      ]
    }
  ];

  const mockSummaryData = {
    totalVulnerabilities: 8,
    filesScanned: 247,
    scanDuration: "2m 34s",
    severityDistribution: [
      { name: "High", value: 3 },
      { name: "Medium", value: 3 },
      { name: "Low", value: 2 }
    ],
    categoryDistribution: [
      { name: "Injection", count: 3 },
      { name: "Auth Failures", count: 2 },
      { name: "Crypto Failures", count: 2 },
      { name: "Access Control", count: 1 }
    ]
  };

  const mockFileTree = [
    {
      name: "src",
      path: "root",
      type: "folder",
      vulnerabilityCount: 8,
      children: [
        {
          name: "auth",
          path: "src/auth",
          type: "folder",
          vulnerabilityCount: 1,
          children: [
            {
              name: "login.js",
              path: "src/auth/login.js",
              type: "file",
              vulnerabilityCount: 1
            }
          ]
        },
        {
          name: "api",
          path: "src/api",
          type: "folder",
          vulnerabilityCount: 3,
          children: [
            {
              name: "auth.js",
              path: "src/api/auth.js",
              type: "file",
              vulnerabilityCount: 1
            },
            {
              name: "userProfile.js",
              path: "src/api/userProfile.js",
              type: "file",
              vulnerabilityCount: 1
            },
            {
              name: "upload.js",
              path: "src/api/upload.js",
              type: "file",
              vulnerabilityCount: 1
            }
          ]
        },
        {
          name: "components",
          path: "src/components",
          type: "folder",
          vulnerabilityCount: 1,
          children: [
            {
              name: "CommentDisplay.jsx",
              path: "src/components/CommentDisplay.jsx",
              type: "file",
              vulnerabilityCount: 1
            }
          ]
        },
        {
          name: "config",
          path: "src/config",
          type: "folder",
          vulnerabilityCount: 1,
          children: [
            {
              name: "api.js",
              path: "src/config/api.js",
              type: "file",
              vulnerabilityCount: 1
            }
          ]
        },
        {
          name: "utils",
          path: "src/utils",
          type: "folder",
          vulnerabilityCount: 1,
          children: [
            {
              name: "encryption.js",
              path: "src/utils/encryption.js",
              type: "file",
              vulnerabilityCount: 1
            }
          ]
        },
        {
          name: "server.js",
          path: "src/server.js",
          type: "file",
          vulnerabilityCount: 1
        }
      ]
    }
  ];

  useEffect(() => {
    setVulnerabilities(mockVulnerabilities);
    setFilteredVulnerabilities(mockVulnerabilities);
  }, []);

  useEffect(() => {
    let filtered = [...vulnerabilities];

    if (searchQuery) {
      filtered = filtered?.filter(vuln =>
        vuln?.ruleName?.toLowerCase()?.includes(searchQuery?.toLowerCase()) ||
        vuln?.filePath?.toLowerCase()?.includes(searchQuery?.toLowerCase()) ||
        vuln?.description?.toLowerCase()?.includes(searchQuery?.toLowerCase())
      );
    }

    if (activeFilters?.severity && activeFilters?.severity !== 'all') {
      filtered = filtered?.filter(vuln =>
        vuln?.severity?.toLowerCase() === activeFilters?.severity?.toLowerCase()
      );
    }

    if (activeFilters?.category && activeFilters?.category !== 'all') {
      filtered = filtered?.filter(vuln =>
        vuln?.owaspCategory?.toLowerCase()?.includes(activeFilters?.category?.toLowerCase())
      );
    }

    setFilteredVulnerabilities(filtered);
  }, [searchQuery, activeFilters, vulnerabilities]);

  const handleViewExplanation = (vulnerability) => {
    setSelectedVulnerability(vulnerability);
    setIsModalOpen(true);
  };

  const handleToggleReview = (id) => {
    setVulnerabilities(prev =>
      prev?.map(vuln =>
        vuln?.id === id ? { ...vuln, isReviewed: !vuln?.isReviewed } : vuln
      )
    );
  };

  const handleSelectVulnerability = (id) => {
    const newSelected = new Set(selectedIds);
    if (newSelected?.has(id)) {
      newSelected?.delete(id);
    } else {
      newSelected?.add(id);
    }
    setSelectedIds(newSelected);
  };

  const handleSelectAll = () => {
    if (selectedIds?.size === filteredVulnerabilities?.length) {
      setSelectedIds(new Set());
    } else {
      setSelectedIds(new Set(filteredVulnerabilities.map(v => v.id)));
    }
  };

  const handleExportPDF = () => {
    alert('Exporting selected vulnerabilities to PDF...');
  };

  const handleExportJSON = () => {
    const selectedVulns = vulnerabilities?.filter(v => selectedIds?.has(v?.id));
    const dataStr = JSON.stringify(selectedVulns, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `vulnerabilities-${new Date()?.toISOString()?.split('T')?.[0]}.json`;
    link?.click();
    URL.revokeObjectURL(url);
  };

  const handleMarkReviewed = () => {
    setVulnerabilities(prev =>
      prev?.map(vuln =>
        selectedIds?.has(vuln?.id) ? { ...vuln, isReviewed: true } : vuln
      )
    );
    setSelectedIds(new Set());
  };

  const handleFileSelect = (file) => {
    const vuln = vulnerabilities?.find(v => v?.filePath === file?.path);
    if (vuln) {
      const element = document.getElementById(`vuln-${vuln?.id}`);
      if (element) {
        element?.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
  };

  return (
    <div className="min-h-screen bg-background">
      <PrimaryNavigation />
      <main className="main-content">
        <div className="max-w-[1600px] mx-auto px-4 py-8">
          <div className="mb-8">
            <h1 className="text-3xl font-bold text-foreground mb-2">
              Vulnerability Dashboard
            </h1>
            <p className="text-muted-foreground">
              Comprehensive security analysis with AI-powered remediation guidance
            </p>
          </div>

          <FilterToolbar
            onSearchChange={setSearchQuery}
            onFilterChange={setActiveFilters}
            onExport={handleExportJSON}
            searchPlaceholder="Search vulnerabilities by name, file, or description..."
          />

          <BulkActionsBar
            selectedCount={selectedIds?.size}
            onExportPDF={handleExportPDF}
            onExportJSON={handleExportJSON}
            onMarkReviewed={handleMarkReviewed}
            onClearSelection={() => setSelectedIds(new Set())}
          />

          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div className="lg:col-span-2 space-y-6">
              <div className="bg-card rounded-lg border border-border p-6">
                <div className="flex items-center justify-between mb-6">
                  <div>
                    <h2 className="text-xl font-semibold text-foreground flex items-center gap-2">
                      <Icon name="AlertTriangle" size={24} />
                      Detected Vulnerabilities
                    </h2>
                    <p className="text-sm text-muted-foreground mt-1">
                      {filteredVulnerabilities?.length} {filteredVulnerabilities?.length === 1 ? 'issue' : 'issues'} found
                    </p>
                  </div>
                  <div className="flex items-center gap-3">
                    <Checkbox
                      label="Select All"
                      checked={selectedIds?.size === filteredVulnerabilities?.length && filteredVulnerabilities?.length > 0}
                      onChange={handleSelectAll}
                    />
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setShowFileTree(!showFileTree)}
                      iconName={showFileTree ? "EyeOff" : "Eye"}
                      iconPosition="left"
                    >
                      {showFileTree ? 'Hide' : 'Show'} File Tree
                    </Button>
                  </div>
                </div>

                {filteredVulnerabilities?.length === 0 ? (
                  <div className="text-center py-12">
                    <div className="w-16 h-16 rounded-full bg-success/10 flex items-center justify-center mx-auto mb-4">
                      <Icon name="CheckCircle" size={32} color="var(--color-success)" />
                    </div>
                    <h3 className="text-lg font-semibold text-foreground mb-2">
                      No vulnerabilities found
                    </h3>
                    <p className="text-sm text-muted-foreground">
                      {searchQuery || Object.keys(activeFilters)?.length > 0
                        ? 'Try adjusting your filters or search query' :'Your code is secure!'}
                    </p>
                  </div>
                ) : (
                  <div className="space-y-4">
                    {filteredVulnerabilities?.map((vulnerability) => (
                      <div key={vulnerability?.id} id={`vuln-${vulnerability?.id}`} className="flex gap-3">
                        <div className="pt-1">
                          <Checkbox
                            checked={selectedIds?.has(vulnerability?.id)}
                            onChange={() => handleSelectVulnerability(vulnerability?.id)}
                          />
                        </div>
                        <div className="flex-1">
                          <VulnerabilityCard
                            vulnerability={vulnerability}
                            onViewExplanation={handleViewExplanation}
                            onToggleReview={handleToggleReview}
                          />
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>

            <div className="space-y-6">
              <ScanSummaryCharts summaryData={mockSummaryData} />
              
              {showFileTree && (
                <FileTreeViewer
                  fileTree={mockFileTree}
                  onFileSelect={handleFileSelect}
                />
              )}
            </div>
          </div>
        </div>
      </main>
      <AIExplanationModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        vulnerability={selectedVulnerability}
      />
    </div>
  );
};

export default VulnerabilityDashboard;